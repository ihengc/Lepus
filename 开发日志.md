## 数据包的设计

1) tcp数据包的设计
2) udp数据包的设计

## 心跳监测

## channel 问题

```go
func (app *Application) Stop() {
app.running = false
app.closeChan <- false
close(app.closeChan)
}
```

Stop方法用来给closeChan发送关闭信息，然后关闭应用。closeChan的接收端会在第一次接收到消息后让应用退出。
若采用在channel发送端关闭的原则，第二遍调用会向一个已经关闭的channel写数据。

如何解决上诉问题?  
在第二次调用时需要知道closeChan是否已经关闭。

```go
func (app *Application) Stop() {
app.running = false
select {
case <-closeChan:
default:
app.closeChan <- false
close(app.closeChan)
}
}
```

通道关闭后，也能继续读取通道里的数据。接收者往往并不知道通道是否已经关闭或者通道中是否还有数据。
若读取已经关闭的通道:

1) 若通道中有数据,则会继续读取通道中的数据
2) 若通道中无数据，则会读取通道类型的零值

### select 机制

select中的case语句用于监听当前通道是否有数据可以读取。
对于已经关闭的通道select认为该通道是有数据读取的。

1) select语句中无default语句
2) select语句中有default语句

## Golang中的网络字节序

## Golang中的int类型

int数据类型的大小是操作系统相关的;利用`unsafe.Sizeof`可以返回数据类型的大小。  
在32位操作系统上int为4个字节；在64位操作系统上int位8个字节。

## 字节序问题

对于整数4的uint8二进制表示为0000100。
什么是大端模式?
数据的高字节保存在内存的低地址中。

### 主机字节序与网络字节序

网络字节序规定为大端模式。

## 数据包

游戏中常用的协议有tcp协议和udp协议。  
数据包数据结构:

1) 路由信息
2) 序列号，用来表示多个数据报之间的顺序，用于udp协议
3) 数据域，存储数据的正文信息
4) 数据正文长度，用于tcp协议中分包
5) 数据包类型
    1) ACK，用于udp协议，确认发送端发送的数据包
    2) SYN，用于udp协议，发送端建立建立时发送的数据包
    3) Heartbeats，心跳包；用于检测服务健康状态
    4) Data：数据包，传递正常的数据

### 数据包的编解码

数据包以二进制的形式进行传递，如何将二进制解析为对象？

### 数据包的加密与解密

### 数据包的压缩与解压缩

## 分布式

1) 分布式系统中一个请求如何定位到某个服务？
2) 分布式系统中的会话如何保持？

## skynet