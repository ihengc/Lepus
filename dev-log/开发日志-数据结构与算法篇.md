## 优先级队列

优先级队列代码:

```go
package util

import (
	"errors"
)

var (
	NilPointErr = errors.New("nil point error")
)

type Comparator interface {
	Compare(e1, e2 interface{}) int
}

type Option func(*PriorityQueue)

type IPriorityQueue interface {
	// Add 将指定元素插入队列中
	Add(e interface{}) (bool, error)
	Offer(e interface{}) (bool, error)
}

type PriorityQueue struct {
	size       int
	comparator Comparator
	queue      []interface{}
}

// grow 调整底层数据大小
func (p *PriorityQueue) grow() {
	var (
		oldCapacity int
		newCapacity int
		newQueue    []interface{}
	)
	oldCapacity = cap(p.queue)
	if oldCapacity < 64 {
		newCapacity = oldCapacity + 2
	} else {
		newCapacity = oldCapacity + oldCapacity>>1
	}
	newQueue = make([]interface{}, newCapacity, newCapacity)
	copy(newQueue, p.queue)
	p.queue = newQueue
}

// siftUp 从指定位置处调整元素，使其满足最小堆的性质
func (p *PriorityQueue) siftUp(k int, x interface{}) {
	for k > 0 {
		parentIndex := (k - 1) >> 1
		parent := p.queue[parentIndex]
		if p.comparator.Compare(parent, x) <= 0 {
			break
		}
		p.queue[k] = parent
		k = parentIndex
	}
	p.queue[k] = x
}

// Add 将元素e插入到队列中
func (p *PriorityQueue) Add(e interface{}) (bool, error) {
	return p.Offer(e)
}

// Offer 将元素e插入到队列中
// 不允许插入为nil的元素
func (p *PriorityQueue) Offer(e interface{}) (bool, error) {
	if e == nil {
		return false, NilPointErr
	}
	if p.size >= cap(p.queue) {
		p.grow()
	}
	p.siftUp(p.size, e)
	p.size++
	return true, nil
}

func SetComparator(comparator Comparator) Option {
	if comparator == nil {
		panic(NilPointErr)
	}
	return func(queue *PriorityQueue) {
		queue.comparator = comparator
	}
}

func NewPriorityQueue(initialCapacity int, options ...Option) *PriorityQueue {
	p := new(PriorityQueue)
	for _, opt := range options {
		opt(p)
	}
	if initialCapacity <= 0 {
		p.queue = make([]interface{}, 11)
	} else {
		p.queue = make([]interface{}, initialCapacity)
	}
	return p
}
```
